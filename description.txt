Project Brief: We are building a Python-based CLI task manager designed to be launched from within vi (via F5 mapping).

Core Mechanics:

File-Based: It parses a markdown-style .txt file where tasks start with [], [x], [-], or [>]. [] means Pending. [x] means Done. [-] means Cancelled. [>] means Deferred (to another day / txt file)

Context-Aware: Prose above a task belongs to that task as a "note."

Subtasks: Indented notes starting with [] or [x] are toggleable sub-actions.

Modal Workflow: It has a "Triage/Command" mode and returns to the host vi session on q.

Prioritization: The p# command bubbles a task (and its notes) to the top.

Current Working Code:

import os
import sys
import re
import glob
from datetime import datetime

# --- CONFIGURATION & ARGUMENTS ---
if len(sys.argv) > 1:
    FILENAME = sys.argv[1]
else:
    FILENAME = datetime.now().strftime('%Y%m%d-notes.txt')

def parse_all():
    if not os.path.exists(FILENAME):
        with open(FILENAME, 'w') as f: f.write("New Session\n")
        
    with open(FILENAME, 'r') as f:
        content = f.read()
    
    # Matches [ ], [], or [x] at the start of a line
    parts = re.split(r'(^\[[ x]?\] .*)', content, flags=re.MULTILINE)
    header = parts[0]
    tasks = []
    
    for i in range(1, len(parts), 2):
        task_line = parts[i]
        note_block = parts[i+1] if i+1 < len(parts) else ""
        notes = [n.strip() for n in note_block.strip().split('\n') if n.strip()]
        tasks.append({'line': task_line, 'notes': notes, 'done': '[x]' in task_line})
    
    return header, tasks

def save_all(header, tasks):
    # This function now takes a single clean list of tasks
    with open(FILENAME, 'w') as f:
        f.write(header.strip() + "\n\n")
        for t in tasks:
            f.write(t['line'].strip() + "\n")
            for n in t['notes']:
                f.write(f"  {n}\n")
            f.write("\n")

def get_timer():
    now = datetime.now()
    target = now.replace(hour=17, minute=0, second=0, microsecond=0)
    diff = (target - now).total_seconds()
    h, m = divmod(int(abs(diff)), 3600)
    return f"{'+' if diff > 0 else '-'}{h:02}:{m//60:02}"

def main():
    last_msg = f"Manager Active: {os.path.basename(FILENAME)}"
    
    while True:
        header, tasks = parse_all()
        os.system('clear')
        
        # Split into working lists
        pending = [t for t in tasks if not t['done']]
        done = [t for t in tasks if t['done']]
        
        print(f"--- {datetime.now().strftime('%H:%M')} | File: {FILENAME} | Deadline 17:00 ({get_timer()}) ---")
        
        if pending:
            active_display = re.sub(r'^\[[ x]?\] ', '', pending[0]['line'])
            print(f"\n\033[1;32mACTIVE: {active_display}\033[0m")
            for j, n in enumerate(pending[0]['notes']):
                print(f"   0.{j}: {n}")
            print("-" * 50)
            
            for i, t in enumerate(pending):
                print(f"{i}: {t['line']}")
        else:
            print("\n(No pending tasks. Press 'q' to return to Vi.)")

        print(f"\n\033[90mStatus: {last_msg}\033[0m")
        cmd = input("[c#.#] [p#] [n text] [S query] [q]uit: ").strip()
        
        if not cmd: continue
        try:
            if cmd == 'q': break
            
            elif cmd.startswith('c'):
                parts = cmd[1:].split('.')
                m_idx = int(parts[0])
                if len(parts) == 1:
                    # Mark as done and move to the 'done' list
                    item = pending.pop(m_idx)
                    item['line'] = re.sub(r'^\[[ ]?\]', '[x]', item['line'])
                    item['done'] = True
                    done.append(item) # Move to bottom
                    last_msg = "Task completed"
                else:
                    s_idx = int(parts[1])
                    note = pending[m_idx]['notes'][s_idx]
                    if '[ ]' in note or '[]' in note:
                        new_n = re.sub(r'\[[ ]?\]', '[x]', note)
                    elif '[x]' in note:
                        new_n = note.replace('[x]', '[ ]')
                    else:
                        new_n = note
                    pending[m_idx]['notes'][s_idx] = new_n
                    last_msg = "Subtask toggled"
            
            elif cmd.startswith('p'):
                idx = int(cmd[1:])
                item = pending.pop(idx)
                pending.insert(0, item)
                last_msg = "Task moved to top"
            
            elif cmd.startswith('n'):
                note_content = cmd[1:].strip() or input("Note text: ")
                if pending:
                    pending[0]['notes'].append(note_content)
                    last_msg = "Added note"
            
            elif cmd.startswith('S'):
                query = cmd[1:].strip() or input("Search all files: ").strip()
                print(f"\n--- GLOBAL SEARCH: {query} ---")
                for file in glob.glob("*.txt"):
                    with open(file, 'r') as f:
                        for i, line in enumerate(f):
                            if query.lower() in line.lower():
                                print(f"\033[94m{file}:{i+1}\033[0m {line.strip()}")
                input("\nPress Enter to return...")
                last_msg = f"Search finished for '{query}'"

            # Re-save exactly what we have in our pending/done lists
            save_all(header, pending + done)
            
        except Exception as e:
            last_msg = f"Error: {e}"

if __name__ == "__main__":
    main()

New Rework Goals:

Triage Mode: This mode is entered by either pressing F5 from a vi session, or typing "t" at the program prompt. Initially, I want to see a numbered list of all lines in the file. If there is a triage marker already in the file, I want to see a numbered list of all the lines after the last triage marker and before the first work marker.
A Triage Marker looks like "------- Triage 6:57 AM -------" where the time is the time when the last triage was completed by moving to Work Mode.
A Work Marker looks like "------- Work 4:45 PM -------" where 4:45 PM is the time the task was processed.
In Triage Mode, I want to be able to do the following:
- Type "a3 2" to assign the note or subtask in the 3 slot to the task at slot 2.
- Type "p2" to move the task at the 2 slot to the top of the list.
- Type "p2 3" to move the task at the 2 slot to slot 3, moving the task currently at slot 3 down in the list. 
- Type "i3" to ignore that line. This removes it from the displayed triage list, but doesn't remove it from the file.
- Type ">" to defer a task to another day (txt file). By default, the file should be "20250130-plan.txt" Where 20250130 is tomorrow's date.
- When exiting Triage Mode into Work Mode, the program should put a triage marker at the bottom of the file. After the marker, it should place the organized tasks and notes in the triaged order.

Work Mode: I want to have a new Work Mode. This mode is entered by the command "w". This displays only the top task from the triage session with any accompanying notes and subtasks. These are displayed in a numbered list allowing me to reference them. I should be able to do the following:
- Type "x" to mark the whole task and all subtasks complete [x].
- Type "x2" to mark the subtask at slot 2 as complete [x].
- Type "-" to cancel a whole task and all pending subtasks [-].
- Type "-1" to cancel the subtask at slot 1.
- Type ">" to defer a task to another day (txt file). By default, the file should be "20250130-plan.txt" Where 20250130 is tomorrow's date.
When a task is completed, cancelled, or deferred, a Work Marker should be placed and the task and its notes and subtasks should be marked accordingly and moved to the bottom of the file.

Task Deadlines: At some point, I want to add support for adding a deadline to a task. The code currently has a few lines for something like this, but it didn't work, and that functionality needs to be further developed. For now, we can ignore this part.

This is the summary Gemini gave me after my work on this today:

Project Brief: DeepWorkCLI
DeepWorkCLI is a modal, text-based task manager designed as a focused "lens" for a chronological journal. It is optimized for vi and enforces a strict separation between collection (Brain Dump), organization (Triage), and execution (Work).

1. Core Mechanics & Syntax
Flexible Task Syntax: Supports both [] (preferred/fast) and [ ] (standard) for pending tasks.

Independent Prose: All lines in the Brain Dump are treated as independent "entities" during Triage. Prose is not automatically attached to a task.

Manual Association: Prose only becomes a "note" if the user manually assigns it to a task during Triage using the a (assign) command.

Ledger Strategy: The program primarily appends to the file, preserving a chronological history of thoughts and actions.

2. Modal Workflow
Brain Dump (vi): Fast, free-form writing at the bottom of the file.

Triage Mode: Numbered list of all new lines.

a#.# #: Moves any line (prose or task) to be a sub-note/sub-task of another.

p#: Promotes a line to the top.

Work Mode: Hyper-focus on the top-indexed task.

90-Minute Focus Guard: Visual alert (inverted colors) if a task exceeds 90 minutes.

3. Future Roadmap
Deadline Timer: Support for specific time-of-day deadlines (e.g., [] Submit report @14:00) with a countdown in the Work header.

Auditory Feedback: Integration of a system "chime" or bell when the 90-minute focus limit is reached or a deadline is hit.

Global Logging: A summary tool to aggregate "Work" blocks across multiple days for weekly reviews.

There are a couple of problems with it. Specifically:
- This line indicates syntax that I don't agree with: a#.# #: Moves any line (prose or task) to be a sub-note/sub-task of another.
- No p# # syntax is mentioned even though I specifically requested it. We'll see if it works in the code.
- No i# is mentioned. Maybe I missed that. This should ignore the line from the list being triaged to focus on the next line.

## Project Brief: DeepWorkCLI (v3.4)

**DeepWorkCLI** is a modal, text-based task manager designed to act as a focused "lens" for a chronological journal. It is optimized for use within **vi** and enforces a strict separation between thought-collection (**Free Write**), organization (**Triage**), and execution (**Work**).

### 1. The Ledger & Free Write Philosophy

* 
**Ledger Strategy:** The program primarily appends to the file, preserving a chronological history of thoughts and actions rather than editing in place.
* 
**Free Write Phase:** Users write freely at the bottom of a `.txt` file. The program identifies "active" material by parsing everything after the last timestamped marker.
* 
**Hierarchy-Aware Parsing:** Leading indentation (two spaces) in the Free Write is recognized as a task/note relationship. Any line starting with spaces is automatically tucked under the task above it.

### 2. Syntax & Parsing

* 
**Flexible Task Syntax:** Supports both `[]` and `[ ]` for pending tasks.
* 
**Independent Prose:** All lines in the Free Write are treated as independent "entities" unless indented or manually assigned.
* 
**Orphan-Proofing:** The parser strictly ignores any line (indented or top-level) starting with a status marker: `[x]` (Done), `[-]` (Cancelled), or `[>]` (Deferred).

### 3. Modal Workflow

#### **Triage Mode**

* 
**Reordering:** `p# #` moves an entry to a specific slot and shifts others down.
* 
**Assignment:** `a# #` manually attaches prose or subtasks to a parent task.
* 
**Ignore:** `i#` hides a line from the current session without modifying the file.

#### **Work Mode**

* 
**Hyper-Focus UI:** Displays only the active task and its hierarchy.
* 
**Subtask Toggling:** `x#` allows checking off sub-items without completing the parent task.
* 
**90-Minute Focus Guard:** Visual alert (inverted colors) if a task exceeds 90 minutes.

#### **Deferral & Exit**

* 
**Hierarchical Deferral:** `>` marks the task `[>]` locally and appends the entire hierarchy (preserving internal states) to tomorrowâ€™s file.
* 
**Consolidated Deferral:** Multiple deferred tasks are grouped under a single "Deferred from Today" header in the future file to ensure they are ready for triage.
* 
**The Rescue Append:** If a session is interrupted (`q` in Work Mode), uncompleted tasks are moved back to the Free Write area with hierarchy intact.
* 
**Daily Scorecard:** Upon quitting, the CLI displays a summary of tasks Finished, Cancelled, and Deferred for that specific file.

### 4. Future Roadmap

* 
**Deadline Timer:** Countdown in the Work header for tasks with specific time-of-day deadlines.
* 
**Auditory Feedback:** System chimes for focus limits and deadlines.
*
**Notes in Work Mode:** I'd like to be able to add a note in work mode before checking it off. This allows me to remain focused on the task at hand while still capturing the information in my journal for the day.
*
**Free Write Marker:** I think I want a Free Write marker to be placed when re-entering Free Write after completing a work session. This gives a clean visual divider to give a fresh start to a free write.
*
**Break Time:** From Work Mode, I want to be able to type "b#" to take a break for that many minutes and have a chime go off when the break is over. This should also place a Break marker in the file indicating the length of the break when I return and type "w" to enter work mode again which should again show me the next pending task in my triaged list.
*
**Add notes and tasks in Work Mode:** In work mode, I want to be able to add notes about the current task. I also want to be able to add tasks and subtasks while in Work Mode. The reason for this is that I often have a task to gather other tasks. This means that while completing that task, I am in work mode, not free-write mode. Bother. Now I'm asking the program to be in free-write and work mode at the same time.... The difference would be that new tasks should disappear after they are entered. However, what if I have to add a note to them as well? I guess I have to add the task and the note on the same line. It's beginning to feel like I would be better off simply doing this directly in vi in the text file. The only thing that the program is giving me is a focus mode and a task timer.
*
**Task Timer vs Work Mode Timer:** Currently, the timer resets after every task. This is fine to have a task timer. However, it may be helpful to have an over-all work mode timer that reminds me to take a break after I've been in work mode for a certain period of time.
*
**Visually move tasks:** I want to be able to visually move tasks in Triage Mode. I want a listener such that I can move a line cursor up and down in the list of tasks. This is simply a visual selector. Then I want to be able to hold another key down while pressing jkhl to move tasks or notes down, up, left, and right like moving the cursor in vi. This would allow for a much more intuitive triage experience. I can do the same in vi using "dd" and then "p" or "P". However, this risks losing the task in the buffer if I forget to paste it. There is likely a native vi way to do this. I don't know if I want to do it in plain vi or do it in my python program. I guess we'll see after I try to do it.

### 5. Issues to Investigate

*
**Interuption Logic:** I don't know exactly how it happens, but when I interupt a session with unfinished tasks and typing "q", it appears that the pending tasks are duplicated at the end of my free write at the bottom of the file.
*
**Ignored Notes in Work Mode:** Ignored notes are showing up in work mode. I think this has to do with the fact that there is flaw in the logic of the reordering vs ignoring. When I reorder the notes, then ignore a note, then assign a task, etc. Some things start to disappear or reappear in the list that have been ignored. I think it has to do with when a task is assigned as a subtask of another.
*
**Triage and work markers not placed:** After a triage and then "q", (I think), the triage marker doesn't get placed. A similar thing happens when exiting work mode via "q", although that may be slightly different. In any case, there is some strange duplication that happens. However, I think the duplication is technically expected except that there should be a marker between it to indicate it was part of a triage session.
